"""
ReUnity Reflection Layer - MirrorLink Dialogue Companion

This module implements the MirrorLink Dialogue Companion (MLDC) which provides
empathetic, trauma-informed conversational support that adapts to the user's
current emotional state and communication preferences.

The key principle is reflecting contradictions without invalidation - helping
users hold multiple truths simultaneously without forcing resolution or
dismissing any part of their experience.

Example: "You feel betrayed now, but you also called them your anchor last week.
Can both be real?"

DISCLAIMER: This is not a clinical or treatment document. It is a theoretical
and support framework only.

Author: Christopher Ezernack
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any

from reunity.core.entropy import EntropyState


class ReflectionType(Enum):
    """Types of reflections the system can provide."""

    CONTRADICTION_HOLDING = "contradiction_holding"
    VALIDATION = "validation"
    GROUNDING = "grounding"
    PERSPECTIVE = "perspective"
    MEMORY_BRIDGE = "memory_bridge"
    EMOTIONAL_NAMING = "emotional_naming"
    PATTERN_AWARENESS = "pattern_awareness"


class CommunicationStyle(Enum):
    """Communication style preferences."""

    DIRECT = "direct"
    GENTLE = "gentle"
    MINIMAL = "minimal"
    DETAILED = "detailed"
    SOMATIC = "somatic"  # Body-focused


@dataclass
class Reflection:
    """A reflection generated by the system."""

    reflection_type: ReflectionType
    content: str
    current_context: str
    past_context: str | None
    entropy_state: EntropyState
    confidence: float
    is_contradiction: bool
    follow_up_question: str | None = None
    grounding_prompt: str | None = None
    metadata: dict[str, Any] = field(default_factory=dict)


@dataclass
class EmotionalContext:
    """Context for emotional state tracking."""

    current_emotion: str
    intensity: float  # 0-1
    body_sensation: str | None
    trigger: str | None
    timestamp: datetime = field(default_factory=datetime.now)


class MirrorLinkDialogueCompanion:
    """
    MirrorLink Dialogue Companion (MLDC).

    Provides empathetic, trauma-informed conversational support that adapts
    to the user's current emotional state. The companion uses controlled,
    structured reflections rather than open-ended text generation.

    Core principles:
    1. Reflect contradictions without invalidation
    2. Hold multiple truths simultaneously
    3. Never gaslight or dismiss experiences
    4. Provide grounding when needed
    5. Respect user autonomy

    DISCLAIMER: This is not a clinical or treatment document. It is a
    theoretical and support framework only.
    """

    def __init__(
        self,
        default_style: CommunicationStyle = CommunicationStyle.GENTLE,
        include_grounding: bool = True,
        max_reflection_length: int = 500,
    ) -> None:
        """
        Initialize the dialogue companion.

        Args:
            default_style: Default communication style.
            include_grounding: Whether to include grounding prompts.
            max_reflection_length: Maximum length of reflections.
        """
        self.default_style = default_style
        self.include_grounding = include_grounding
        self.max_reflection_length = max_reflection_length

        # Track emotional context history
        self._emotional_history: list[EmotionalContext] = []

        # Track reflections provided
        self._reflection_history: list[Reflection] = []

    def reflect(
        self,
        current_emotion: str,
        past_context: str | None = None,
        entropy_state: EntropyState = EntropyState.STABLE,
        style: CommunicationStyle | None = None,
    ) -> Reflection:
        """
        Generate a reflection based on current emotion and past context.

        This is the core function that implements "reflecting contradictions
        without invalidation."

        Args:
            current_emotion: The user's current emotional state/feeling.
            past_context: Relevant past context that may seem contradictory.
            entropy_state: Current entropy state.
            style: Communication style override.

        Returns:
            A Reflection object with the generated content.
        """
        style = style or self.default_style

        # Detect if there's a contradiction
        is_contradiction = self._detect_contradiction(current_emotion, past_context)

        # Generate appropriate reflection
        if is_contradiction:
            reflection = self._generate_contradiction_reflection(
                current_emotion,
                past_context,
                style,
                entropy_state,
            )
        else:
            reflection = self._generate_validation_reflection(
                current_emotion,
                style,
                entropy_state,
            )

        # Add grounding if needed
        if self.include_grounding and entropy_state in [
            EntropyState.HIGH,
            EntropyState.CRISIS,
        ]:
            reflection.grounding_prompt = self._generate_grounding_prompt(entropy_state)

        # Store in history
        self._reflection_history.append(reflection)

        return reflection

    def _detect_contradiction(
        self,
        current_emotion: str,
        past_context: str | None,
    ) -> bool:
        """
        Detect if there's a contradiction between current and past.

        A contradiction exists when the current emotional state seems
        to conflict with documented past experiences or statements.
        """
        if not past_context:
            return False

        # Simple sentiment analysis for contradiction detection
        current_sentiment = self._analyze_sentiment(current_emotion)
        past_sentiment = self._analyze_sentiment(past_context)

        # Contradiction if sentiments are significantly different
        return abs(current_sentiment - past_sentiment) > 0.5

    def _analyze_sentiment(self, text: str) -> float:
        """
        Analyze sentiment of text.

        Returns value from -1 (negative) to 1 (positive).
        """
        positive_words = {
            "love", "safe", "happy", "trust", "anchor", "good", "calm",
            "peace", "joy", "grateful", "supported", "understood",
        }
        negative_words = {
            "hate", "unsafe", "angry", "betrayed", "hurt", "bad", "scared",
            "anxious", "sad", "alone", "abandoned", "misunderstood",
        }

        words = text.lower().split()
        positive = sum(1 for w in words if w in positive_words)
        negative = sum(1 for w in words if w in negative_words)

        total = positive + negative
        if total == 0:
            return 0.0

        return (positive - negative) / total

    def _generate_contradiction_reflection(
        self,
        current_emotion: str,
        past_context: str,
        style: CommunicationStyle,
        entropy_state: EntropyState,
    ) -> Reflection:
        """
        Generate a reflection that holds contradictory truths.

        The key is to acknowledge both realities without forcing
        resolution or invalidating either experience.
        """
        # Style-specific templates
        templates = {
            CommunicationStyle.DIRECT: (
                f"You feel {current_emotion} now, but {past_context}. "
                "Both can be true. What might explain this difference?"
            ),
            CommunicationStyle.GENTLE: (
                f"Right now, you're experiencing {current_emotion}. "
                f"I also remember that {past_context}. "
                "It's okay for both of these to be real at the same time. "
                "Would you like to explore what's different now?"
            ),
            CommunicationStyle.MINIMAL: (
                f"Now: {current_emotion}. Before: {past_context}. "
                "Both real. What changed?"
            ),
            CommunicationStyle.DETAILED: (
                f"I notice you're feeling {current_emotion} right now. "
                f"This seems different from what we've recorded before, "
                f"where {past_context}. "
                "In trauma recovery, it's common for our feelings about "
                "people and situations to shift, sometimes dramatically. "
                "Both your current experience and your past experience are valid. "
                "Would it help to look at what might have triggered this shift?"
            ),
            CommunicationStyle.SOMATIC: (
                f"You're feeling {current_emotion}. "
                "Where do you notice this in your body? "
                f"I remember when you felt differently - {past_context}. "
                "Both experiences live in you. "
                "Can you breathe into the space between them?"
            ),
        }

        content = templates.get(style, templates[CommunicationStyle.GENTLE])

        # Adjust for high entropy states
        if entropy_state in [EntropyState.HIGH, EntropyState.CRISIS]:
            content = self._simplify_for_crisis(content)

        follow_up = self._generate_follow_up(current_emotion, past_context, style)

        return Reflection(
            reflection_type=ReflectionType.CONTRADICTION_HOLDING,
            content=content,
            current_context=current_emotion,
            past_context=past_context,
            entropy_state=entropy_state,
            confidence=0.8,
            is_contradiction=True,
            follow_up_question=follow_up,
        )

    def _generate_validation_reflection(
        self,
        current_emotion: str,
        style: CommunicationStyle,
        entropy_state: EntropyState,
    ) -> Reflection:
        """
        Generate a validating reflection when there's no contradiction.
        """
        templates = {
            CommunicationStyle.DIRECT: (
                f"Your feeling of {current_emotion} makes sense "
                "given your recent experiences."
            ),
            CommunicationStyle.GENTLE: (
                f"I hear that you're feeling {current_emotion}. "
                "That's a valid response to what you're going through. "
                "I'm here with you."
            ),
            CommunicationStyle.MINIMAL: (
                f"Feeling {current_emotion}. That makes sense."
            ),
            CommunicationStyle.DETAILED: (
                f"You're experiencing {current_emotion} right now. "
                "Looking at your recent experiences and patterns, "
                "this emotional response is understandable and valid. "
                "Your feelings are giving you important information."
            ),
            CommunicationStyle.SOMATIC: (
                f"You're feeling {current_emotion}. "
                "Take a moment to notice where this lives in your body. "
                "Your body is telling you something important."
            ),
        }

        content = templates.get(style, templates[CommunicationStyle.GENTLE])

        if entropy_state in [EntropyState.HIGH, EntropyState.CRISIS]:
            content = self._simplify_for_crisis(content)

        return Reflection(
            reflection_type=ReflectionType.VALIDATION,
            content=content,
            current_context=current_emotion,
            past_context=None,
            entropy_state=entropy_state,
            confidence=0.9,
            is_contradiction=False,
        )

    def _simplify_for_crisis(self, content: str) -> str:
        """Simplify content for crisis states."""
        # Shorten and simplify
        sentences = content.split(". ")
        if len(sentences) > 2:
            content = ". ".join(sentences[:2]) + "."

        return content

    def _generate_follow_up(
        self,
        current_emotion: str,
        past_context: str,
        style: CommunicationStyle,
    ) -> str:
        """Generate an appropriate follow-up question."""
        follow_ups = {
            CommunicationStyle.DIRECT: "What do you think changed?",
            CommunicationStyle.GENTLE: "Would you like to explore this together?",
            CommunicationStyle.MINIMAL: "What shifted?",
            CommunicationStyle.DETAILED: (
                "Would it help to look at the timeline of events "
                "that might have led to this shift?"
            ),
            CommunicationStyle.SOMATIC: (
                "Can you notice what happens in your body "
                "when you hold both of these truths?"
            ),
        }

        return follow_ups.get(style, follow_ups[CommunicationStyle.GENTLE])

    def _generate_grounding_prompt(self, entropy_state: EntropyState) -> str:
        """Generate a grounding prompt based on entropy state."""
        if entropy_state == EntropyState.CRISIS:
            return (
                "Let's pause for a moment. "
                "Can you feel your feet on the ground? "
                "You are safe right now, in this moment."
            )
        elif entropy_state == EntropyState.HIGH:
            return (
                "Take a breath with me. "
                "Notice five things you can see around you."
            )
        else:
            return "Take a moment to notice your breathing."

    def generate_memory_bridge(
        self,
        current_state: str,
        past_memory: str,
        relationship: str | None = None,
    ) -> Reflection:
        """
        Generate a memory bridge reflection.

        Helps connect current experience to past memories in a
        supportive way, especially useful during dissociative episodes.

        Args:
            current_state: Current emotional/identity state.
            past_memory: Relevant past memory to bridge to.
            relationship: Optional relationship context.

        Returns:
            A memory bridge Reflection.
        """
        if relationship:
            content = (
                f"Right now you're in a {current_state} state. "
                f"I want to remind you of something from before: {past_memory}. "
                f"This is connected to your relationship with {relationship}. "
                "This memory is part of your story, even if it feels distant now."
            )
        else:
            content = (
                f"You're experiencing {current_state} right now. "
                f"I'm holding this memory for you: {past_memory}. "
                "It's still part of you, even if you can't fully access it now."
            )

        return Reflection(
            reflection_type=ReflectionType.MEMORY_BRIDGE,
            content=content,
            current_context=current_state,
            past_context=past_memory,
            entropy_state=EntropyState.ELEVATED,
            confidence=0.7,
            is_contradiction=False,
            metadata={"relationship": relationship},
        )

    def generate_pattern_awareness(
        self,
        pattern_description: str,
        occurrences: int,
        context: str,
    ) -> Reflection:
        """
        Generate a pattern awareness reflection.

        Gently brings attention to recurring patterns without judgment.

        Args:
            pattern_description: Description of the pattern.
            occurrences: Number of times pattern has occurred.
            context: Current context.

        Returns:
            A pattern awareness Reflection.
        """
        content = (
            f"I've noticed something that might be helpful to be aware of. "
            f"{pattern_description} "
            f"This has come up {occurrences} times in our records. "
            "I'm not saying this is good or bad - just offering this "
            "observation for you to consider. "
            "You know your situation best."
        )

        return Reflection(
            reflection_type=ReflectionType.PATTERN_AWARENESS,
            content=content,
            current_context=context,
            past_context=pattern_description,
            entropy_state=EntropyState.STABLE,
            confidence=0.6,
            is_contradiction=False,
            follow_up_question="Does this pattern resonate with your experience?",
        )

    def name_emotion(
        self,
        description: str,
        body_sensation: str | None = None,
    ) -> Reflection:
        """
        Help name and validate an emotional experience.

        Args:
            description: User's description of their experience.
            body_sensation: Optional body sensation description.

        Returns:
            An emotional naming Reflection.
        """
        # Simple emotion detection from description
        emotions_detected = self._detect_emotions(description)

        if emotions_detected:
            emotion_str = ", ".join(emotions_detected)
            content = (
                f"What you're describing sounds like it might include "
                f"feelings of {emotion_str}. "
            )
        else:
            content = "What you're experiencing sounds significant. "

        if body_sensation:
            content += (
                f"You mentioned feeling this as {body_sensation} in your body. "
                "That body awareness is valuable information. "
            )

        content += "Does this naming feel accurate to you?"

        return Reflection(
            reflection_type=ReflectionType.EMOTIONAL_NAMING,
            content=content,
            current_context=description,
            past_context=None,
            entropy_state=EntropyState.STABLE,
            confidence=0.7,
            is_contradiction=False,
            follow_up_question="What would you call this feeling?",
            metadata={
                "detected_emotions": emotions_detected,
                "body_sensation": body_sensation,
            },
        )

    def _detect_emotions(self, text: str) -> list[str]:
        """Detect emotions mentioned in text."""
        emotion_keywords = {
            "anger": ["angry", "furious", "rage", "irritated", "frustrated"],
            "sadness": ["sad", "depressed", "grief", "loss", "lonely"],
            "fear": ["scared", "afraid", "anxious", "worried", "terrified"],
            "joy": ["happy", "joyful", "excited", "grateful", "content"],
            "shame": ["ashamed", "embarrassed", "humiliated", "guilty"],
            "love": ["loving", "caring", "connected", "attached"],
            "betrayal": ["betrayed", "deceived", "lied to", "cheated"],
            "confusion": ["confused", "lost", "uncertain", "disoriented"],
        }

        text_lower = text.lower()
        detected = []

        for emotion, keywords in emotion_keywords.items():
            if any(kw in text_lower for kw in keywords):
                detected.append(emotion)

        return detected

    def get_reflection_history(self) -> list[Reflection]:
        """Get history of reflections provided."""
        return self._reflection_history.copy()

    def clear_history(self) -> None:
        """Clear reflection history."""
        self._reflection_history.clear()
        self._emotional_history.clear()

    def add_emotional_context(
        self,
        emotion: str,
        intensity: float,
        body_sensation: str | None = None,
        trigger: str | None = None,
    ) -> None:
        """
        Add emotional context for tracking.

        Args:
            emotion: The emotion being experienced.
            intensity: Intensity level (0-1).
            body_sensation: Where it's felt in the body.
            trigger: What triggered the emotion.
        """
        context = EmotionalContext(
            current_emotion=emotion,
            intensity=intensity,
            body_sensation=body_sensation,
            trigger=trigger,
        )
        self._emotional_history.append(context)

        # Trim history
        if len(self._emotional_history) > 100:
            self._emotional_history = self._emotional_history[-100:]
